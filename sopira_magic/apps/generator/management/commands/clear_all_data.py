#..............................................................
#   ~/sopira.magic/version_01/sopira_magic/apps/generator/management/commands/clear_all_data.py
#   Clear All Data Command - Management command
#   CLI command for clearing all business data without regeneration
#..............................................................

"""
   Clear All Data Command - Management Command.

   Django management command for clearing all business data generated by the
   generator app. This command only deletes data, it does NOT regenerate it.

   This command:
   1. Clears all RelationInstance records
   2. Clears all business data for models defined in GENERATOR_CONFIG
   3. Respects dependency order (deletes children before parents)
   4. Optionally preserves users if --keep-users flag is set

   Usage:
   ```bash
   # Clear all business data (including users)
   python manage.py clear_all_data

   # Clear all business data but keep users
   python manage.py clear_all_data --keep-users

   # Preview what would be deleted (dry run)
   python manage.py clear_all_data --dry-run
   ```

   Arguments:
   - --keep-users: Keep existing users (don't delete)
   - --dry-run: Show what would be deleted without actually deleting

   Note:
   This command only clears data. To regenerate data after clearing,
   use `python manage.py generate_all_data` or `python manage.py generate_data --seed`.
"""

from django.core.management.base import BaseCommand, CommandError
from sopira_magic.apps.generator.services import GeneratorService
from sopira_magic.apps.generator.config import get_all_generator_configs
from sopira_magic.apps.relation.models import RelationInstance
from django.db import transaction


class Command(BaseCommand):
    help = 'Clear all business data generated by the generator app (without regeneration)'

    def add_arguments(self, parser):
        parser.add_argument(
            '--keep-users',
            action='store_true',
            help='Keep existing users (don\'t delete)',
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be deleted without actually deleting',
        )

    def handle(self, *args, **options):
        keep_users = options.get('keep_users')
        dry_run = options.get('dry_run')
        
        if dry_run:
            self.stdout.write(self.style.WARNING('DRY RUN MODE - No changes will be made\n'))
        
        # Step 1: Clear RelationInstance records
        self.stdout.write(self.style.SUCCESS('Step 1: Clearing RelationInstance records...'))
        if not dry_run:
            instance_count = RelationInstance.objects.count()
            RelationInstance.objects.all().delete()
            self.stdout.write(self.style.SUCCESS(f'   ✓ Deleted {instance_count} relation instances\n'))
        else:
            instance_count = RelationInstance.objects.count()
            self.stdout.write(self.style.WARNING(f'   Would delete {instance_count} relation instances\n'))
        
        # Step 2: Clear generated data (in reverse dependency order)
        self.stdout.write(self.style.SUCCESS('Step 2: Clearing generated data...'))
        
        # Build reverse dependency order (delete children before parents)
        configs = get_all_generator_configs()
        reverse_order = []
        
        # Simple reverse topological sort
        visited = set()
        def add_to_reverse(key):
            if key in visited:
                return
            visited.add(key)
            
            # Add dependencies first
            config = configs[key]
            relations = config.get('relations', {})
            for rel_config in relations.values():
                target_model = rel_config.get('model')
                for dep_key, dep_config in configs.items():
                    if dep_config.get('model') == target_model:
                        add_to_reverse(dep_key)
                        break
            
            reverse_order.append(key)
        
        for key in configs.keys():
            add_to_reverse(key)
        
        # Delete in reverse order
        deleted_counts = {}
        for key in reversed(reverse_order):
            if key == 'user' and keep_users:
                self.stdout.write(self.style.WARNING(f'   Skipping {key} (--keep-users)'))
                continue
            
            if not dry_run:
                try:
                    # Universal cross-database cascade delete is handled by core.signals
                    # No hardcoded model-specific logic needed
                    deleted_count = GeneratorService.clear_data(key, keep_count=0)
                    deleted_counts[key] = deleted_count
                    if deleted_count > 0:
                        self.stdout.write(self.style.SUCCESS(f'   ✓ Cleared {key}: {deleted_count} records'))
                    else:
                        self.stdout.write(f'   → {key}: No records to clear')
                except Exception as e:
                    error_msg = str(e)
                    # If error is about cross-database CASCADE, core.signals should handle it
                    # But Django CASCADE might still try to delete from wrong database
                    if 'does not exist' in error_msg.lower() and ('state_' in error_msg.lower() or 'logging_' in error_msg.lower()):
                        self.stdout.write(self.style.WARNING(f'   ⚠ Cross-database CASCADE error for {key}: {error_msg}'))
                        self.stdout.write(self.style.WARNING(f'   → This should be handled by core.signals - trying raw SQL fallback'))
                        # Fallback: Use raw SQL for this specific model
                        try:
                            config = get_all_generator_configs()[key]
                            model_path = config.get('model')
                            app_label, model_name = model_path.split('.')
                            from django.apps import apps
                            model_class = apps.get_model(app_label, model_name)
                            count = model_class.objects.count()
                            if count > 0:
                                from django.db import connection
                                table_name = model_class._meta.db_table
                                cursor = connection.cursor()
                                cursor.execute(f"DELETE FROM {table_name} CASCADE")
                                deleted_counts[key] = count
                                self.stdout.write(self.style.SUCCESS(f'   ✓ Cleared {key}: {count} records (via raw SQL fallback)'))
                            else:
                                deleted_counts[key] = 0
                                self.stdout.write(f'   → {key}: No records to clear')
                        except Exception as fallback_error:
                            self.stdout.write(self.style.ERROR(f'   ✗ Error clearing {key} (fallback also failed): {str(fallback_error)}'))
                    else:
                        self.stdout.write(self.style.ERROR(f'   ✗ Error clearing {key}: {error_msg}'))
            else:
                # Count existing records
                config = configs[key]
                model_path = config.get('model')
                app_label, model_name = model_path.split('.')
                from django.apps import apps
                model_class = apps.get_model(app_label, model_name)
                count = model_class.objects.count()
                deleted_counts[key] = count
                if count > 0:
                    self.stdout.write(self.style.WARNING(f'   Would clear {key}: {count} records'))
                else:
                    self.stdout.write(f'   → {key}: No records to clear')
        
        total_deleted = sum(deleted_counts.values())
        if total_deleted > 0:
            self.stdout.write(self.style.SUCCESS(f'\n   ✓ Total records cleared: {total_deleted}\n'))
        else:
            self.stdout.write(self.style.WARNING('\n   → No records to clear\n'))
        
        if dry_run:
            self.stdout.write(self.style.WARNING('=== DRY RUN COMPLETE - No data was actually deleted ===\n'))
        else:
            self.stdout.write(self.style.SUCCESS('=== Clear All Data Complete ===\n'))
            self.stdout.write(self.style.SUCCESS('To regenerate data, run:'))
            self.stdout.write(self.style.SUCCESS('  python manage.py generate_all_data'))
            self.stdout.write(self.style.SUCCESS('  or'))
            self.stdout.write(self.style.SUCCESS('  python manage.py generate_data --seed\n'))

